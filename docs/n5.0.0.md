<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
><span style='color:RED'>[ 协程`coroutine`] 是一种轻量级的线程 ( 协程的核心特点是：挂起 + 恢复操作 )</span>
>
>- 挂起：协程可以在 [ 某个点暂停执行 ]
>- 恢复：协程可以从 [ 挂起的地方继续执行 ]
>
>```csharp
>async def M1():
>     await asyncio.sleep(2)
>     return 10
>        
># async：定义一个协程函数 [ 此函数返回一个协程对象 <class 'coroutine'> ]
># await：当前协程暂停并让出执行权 [ 将控制权交还给 event loop ( 事件循环 ) ]
>
>task = M1()
>print(type(task)) // <class 'coroutine'> 
>    
>    
>```
>
>⚠ <span style='color:red'>[ 与线程不同，协程是单线程内的逻辑单元，它们通过显式的挂起(`await`）来让出控制权，而不是抢占式调度 ]</span>
>
><br/>

>[!WARNING|style: flat|label: 单线程事件循环 ]
>
><span style='color:Blue'>[ 单线程 - 事件循环`Single-threaded Event Loop`]</span> 
>
>- [`A`] 事件队列：一个先进先出的队列 <span style='color:red'>[ 存储：待处理的异步任务 ]</span>
>
>- [`B`] 事件循环：一个无限循环 ( 其负责调度 + 执行任务 ) <span style='color:red'>[ 轮询检查：任务队列中是否有待处理的任务 ]</span>
>
>   <span style='color:RED'>[ 已有任务 ]</span> 从队列中取出一个任务执行 <span style='color:red'>[ 在单线程中，同一时间只能执行一个任务 ]</span>
>
>   <span style='color:RED'>[ 未有任务 ]</span> 线程进入空闲状态，等待新的任务到来
>
>
><br/>
>
><span style='color:red'>[ 单线程 - 事件循环工作机制 ]</span>
>
>- 任务切换：通过`await`表达式 <span style='color:red'>[ 实现协程`coroutine`间的控制权转移 ]</span>
>
>- 暂停执行：当遇到`await`时，当前协程`coroutine`暂停并让出执行权 <span style='color:red'>( 将控制权交还给事件循环 )</span>
>- <span style='color:red'>恢复执行：某时刻异步操作完成后 [ 事件循环会将该协程`coroutine`重新调度回运行状态 ] [ 从挂起点继续运行 ]</span>
>
>
>
>---
>
><span style='color:Blue'>[ 语言生态 ]</span>
>
>- [`C# async`] 基于线程池`ThreadPool`<span style='color:red'>[ 支持多线程并行：适合`CPU`密集型 +`I/O`密集型任务 ]</span>
>
>   <span style='color:red'>[`await`等待一个任务完成 - 释放控制权交给线程池 ] </span>
>
>- [`Python async`] 基于协程`Coroutine`+ 单线程事件循环<span style='color:red'> [ 单线程：只适合`I/O`密集型任务 -  不适合`CPU`密集型任务 ]</span>
>
>   <span style='color:red'>[`await`等待一个协程完成 - 释放控制权交给事件循环 ]</span>
>
>
>
>
>
><br/>
>
>
