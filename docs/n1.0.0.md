<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 在`Python`中，线程池操作通常使用 [` from concurrent.futures import ThreadPoolExecutor`来实现 ]
>
>```csharp
># executor: <class 'concurrent.futures.thread.ThreadPoolExecutor'>
># max_workers: [ 限制并发量 ] 防止 CPU 爆高 
>with ThreadPoolExecutor(max_workers=5) as executor:
>
>{
>
>       #region 常用函数
>
>       // [ 单次 ] 提交任务 -> 线程池处理
>       executor.submit(fn, /, *args, **kwargs) -> Future
>       // [ 批量 ] 提交任务 -> 线程池处理
>       executor.map(fn, *args) -> <class 'generator'>
>
>}
>
>
>```
>
>
>
><br/>

<!-- tabs:start -->

#### **[ 单次任务 ]**

```csharp
# [ 单次 ] 提交任务 -> 线程池处理
with ThreadPoolExecutor(max_workers=5) as executor:
     future = executor.submit((lambda x, y: x + y), x = 10, y = 20)
     v = future.result()

print(v) // 输出 30 [ 阻塞调用线程，直到任务完成并返回结果 ]
         
         
```



#### **[ 批量任务 ]**

```csharp
# [ map ] 按任务提交的顺序返回结果 ( 即使某些任务先完成, map 也会等待前面的任务完成 )
def M1() -> Iterable[int]:
    with ThreadPoolExecutor( max_workers = 5 ) as executor:
        results = executor.map( lambda x: x, [ 1, 2, 3, 4, 5 ] )
        return results
             

```

```csharp
# [ submit ] 按任务完成的顺序返回结果 ( 某任务完成 -> 立即返回结果 )
def M1() -> Iterable[int]:
    with ThreadPoolExecutor( max_workers = 5 ) as executor:
        futures = [ executor.submit( lambda x: x, i ) for i in [ 5, 4, 3, 2, 1 ] ]
        for future in as_completed( futures ):
            yield future.result()


```



<!-- tabs:end -->





`



