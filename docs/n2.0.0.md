<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- <span style='color:red'>(`threading.Lock`) 最基本的锁机制，用于确保同一时间只有一个线程可以执行某个代码块 [`import threading`]</span>
>
>  <span style='color:red'>[ 通过`with lock:`自动处理锁的获取和释放 ]</span>
>
>
>
>```csharp
>import threading
>
>{
>
>      // blocking = True:  请求锁 ( 阻塞: 如果锁当前被其他线程持有 - 直到锁变得可用 )
>      // blocking = False: 请求锁 ( 非阻塞: 如果锁当前被其他线程持有 - 则返回 False 而不会阻塞 )
>      lock.acquire(blocking)
>      lock.release()
>
>      // [ 延迟执行 ]
>      threading.Timer(interval, function, args=Nonee):
>         
>}
>
>
>```
>
>
>
><br/>

<!-- tabs:start -->

#### **Lock**

```csharp
_execution_lock = threading.Lock()

def connect_mssql_with_pyodbc(**kwargs):

	# [ 尝试获取锁 ]
	if not _execution_lock.acquire(blocking = False):
		return None

	try:
		print(f"逻辑处理: 同一时刻只允许一个线程处理 !")
	except Exception as e:
		print(f"其他错误: {e}")
	finally:
		_execution_lock.release()

       
```



#### **[ 定时器 ]Timer**

```csharp
def background_task(connection_string):
	def run_task():
        
		print("定时任务 .....:")

		# [ 定时器 ] 间隔执行
		timer = threading.Timer(10.0, run_task)
		timer.daemon = True
		timer.start()

	run_task()
                
                
```



<!-- tabs:end -->









