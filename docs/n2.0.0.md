<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- <span style='color:red'>(`threading.Lock`) 最基本的锁机制，用于确保同一时间只有一个线程可以执行某个代码块 [`import threading`]</span>
>
>  <span style='color:red'>[ 通过`with lock:`自动处理锁的获取和释放 ] [ 注意事项：锁不可重入 ]</span>
>
>
>
>
>```csharp
>import threading
>
>{
>      
>      # lock.acquire: 锁不可重入
>      # - blocking = True:  请求锁 ( 阻塞: 如果锁当前被其他线程持有 - 直到锁变得可用 )
>      # - blocking = False: 请求锁 ( 非阻塞: 如果锁当前被其他线程持有 - 则返回 False 而不会阻塞 )
>      lock.acquire(blocking)
>      lock.release()
>
>}
>
>
>```
>
>
>
><br/>

```csharp
_lock = threading.Lock()
def M1():
    # with: 自动 .acquire() .release()
	with _lock:
		print('逻辑处理: 同一时刻只允许一个线程处理!')
            
            
```

```csharp
_lock = threading.Lock()
def M1():

	# [ 尝试获取锁 ]
	if not _lock.acquire(blocking = False):
		return None

	try:
		print(f"逻辑处理: 执行实际业务逻辑 !")
	except Exception as e:
		print(f"其他错误: {e}")
	finally:
		# 确保释放锁
		_lock.release()
	return None
            
            
```





