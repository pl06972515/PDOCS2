<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- (`asyncio`) 是`Python`中用于处理异步任务的核心模块<span style='color:red'> [ 支持异步`I/O`、事件循环、协程和任务调度 ]</span>
>
>```csharp
>import asyncio
>{
>
>      # [ 运行协程 ] 自动管理事件循环的创建和关闭
>      asyncio.run(coroutine)
>      # [ 暂停任务 ] 时间单位 ( 秒 )
>      asyncio.sleep(delay) -> <class 'coroutine'>
>
>      # [ 函数包装 ] 将同步函数包装成携程任务 → 调度到线程池中运行
>      /// <summary>
>      /// def M1(x):
>      ///     time.sleep(x)
>	  ///     return x
>      ///
>      /// async def M2():
>      ///     result = await asyncio.to_thread(M1, x = 10)
>      ///     return result
>      ///
>      /// </summary>
>      asyncio.to_thread(blocking_function, *args, **kwargs) -> <class 'coroutine'>
>
>      # [ 协程并发 ] 并发执行多个协程 ( 阻塞：等待所有任务完成 - 按提交顺序返回 )
>      asyncio.gather(*coroutines, return_exceptions = False):
>
>      # ( Python v3.11 ) 将携程对象包装成任务 ( 提供比 asyncio.gather 更安全的任务管理机制 )
>      /// <summary>
>      /// 通过上下文管理器语法 【确保任务的正确生命周期管理】
>      /// - 确保所有任务在 [ 退出 async with 块前完成 ]
>      /// - 自动清理未完成的任务
>      /// - [ 避免任务泄露问题 ]
>      /// 
>      /// ------------------------------------------------
>      /// 
>      /// - 【携程任务】
>      /// async def M1(url):
>      ///    await asyncio.sleep(1)
>      ///    return "Hello Word"
>      /// 
>      /// async def Main():
>      ///    async with asyncio.TaskGroup() as tg:
>      ///        task1 = tg.create_task(M1("url1"))
>      ///        task2 = tg.create_task(M1("url2"))
>      ///
>      ///    # [ 获取结果 ]
>      ///    result1 = task1.result()
>      ///    result2 = task2.result()
>      /// 
>      /// </summary>
>      asyncio.TaskGroup()
>
>      # [ 异步锁 ] 非阻塞式 ( 当一个协程获取锁后: 其他协程不会被阻塞, 而是会挂起 - 允许事件循环调度其他任务 )
>      /// <summary>
>      /// lock = asyncio.Lock()
>      /// async def M1():
>      ///     async with lock:
>      ///         await asyncio.sleep(1)
>      ///         return 10
>      ///
>      /// </summary>
>      asyncio.Lock()
>
>}
>
>
>```
>
>
>
><br/>



<!-- tabs:start -->

#### **[ 基本操作  ]**

```csharp
# Task.CompletedTask
async def M1():
      return None

# Task.FromResult<int>(100)
async def M2():
      return 100


```

```csharp
# Task<int>
async def M1(delay: int) -> int:
	await asyncio.sleep(delay)
	return delay

# 1
o = asyncio.run(M1(1))
print(o)
        
        
```



#### **[ 异步迭代 ]**

```csharp
async def M1(x : int):
    await asyncio.sleep(x)
    return x
        

```



```csharp
# [ 阻塞 ] 等待所有任务完成 ( 按提交顺序返回 )
async def M2() -> Iterable[int]:
    async with asyncio.TaskGroup() as tg:
        tasks = [tg.create_task(M1(i)) for i in [1, 2, 3, 4, 5]]

    res = [ x.result() for x in tasks ]
    return res
            
async def main():
	for x in await M2():
		print(x)

asyncio.run(main())
            
            
```

```csharp
# [ 非阻塞 ] 1,... 2,... 3,...
async def M2() -> AsyncIterable[int]:
    async with asyncio.TaskGroup() as tg:
        tasks = [tg.create_task(M1(i)) for i in [1, 2, 3, 4, 5]]
        for task in tasks:
            yield await task

async def main():
	# 在 Python 中 async for : 用于异步迭代
	async for x in M2():
		print(x)

asyncio.run(main())
            
            
```



<!-- tabs:end -->





