<br/>

>[!WARNING|style: flat|label: 简要说明 ]
>
>- (`asyncio`) 是`Python`中用于处理异步任务的核心模块<span style='color:red'> [ 支持异步`I/O`、事件循环、协程和任务调度 ]</span>
>
>```csharp
>import asyncio
>{
>
>      # [ 运行协程 ] 自动管理事件循环的创建和关闭
>      asyncio.run(coroutine)
>      # [ 暂停任务 ] 时间单位 ( 秒 )
>      asyncio.sleep(delay) -> <class 'coroutine'>
>
>      # [ 函数包装 ] 将同步函数调度到 - 线程池中运行
>      /// <summary>
>      /// def M1(x):
>      ///     time.sleep(x)
>	  ///     return x
>      ///
>      /// async def M2():
>      ///     result = await asyncio.to_thread(M1, x = 10)
>      ///     return result
>      ///
>      /// </summary>
>      asyncio.to_thread(blocking_function, *args, **kwargs) -> <class 'coroutine'>
>
>      # [ 协程并发 ] 并发执行多个协程 ( 阻塞：等待所有任务完成 - 按提交顺序返回 )
>      asyncio.gather(*coroutines, return_exceptions = False):
>
>      # ( Python 3.11 ) 提供比 asyncio.gather 更安全的任务管理机制
>      /// <summary>
>      /// 通过上下文管理器语法 【确保任务的正确生命周期管理】
>      /// - 确保所有任务在 [ 退出 async with 块前完成 ]
>      /// - 自动清理未完成的任务
>      /// - 避免 [ 任务泄露问题 ]
>      /// 
>      /// ------------------------------------------------
>      /// 
>      /// async def M1(url):
>      ///     await asyncio.sleep(1)
>      ///     return "Hello Word"
>      /// 
>      /// async def Main():
>      ///     async with asyncio.TaskGroup() as tg:
>      ///        task1 = tg.create_task(M1("url1"))
>      ///        task2 = tg.create_task(M1("url2"))
>      ///
>      ///     # [ 获取结果 ]
>      ///     result1 = task1.result()
>      ///     result2 = task2.result()
>      /// 
>      /// </summary>
>      asyncio.TaskGroup()
> 
>               # [ 异步锁 ] 非阻塞式 ( 当一个协程获取锁后: 其他协程不会被阻塞, 而是会挂起 - 允许事件循环调度其他任务 )
>      /// <summary>
>      /// lock = asyncio.Lock()
>      /// async def M1():
>      ///    async with lock:
>      ///          await asyncio.sleep(1)
>      ///          return 10
>      ///
>      /// </summary>
>      asyncio.Lock()
> 
>}
>
>
>```
>
>
>
><br/>



<!-- tabs:start -->

#### **[ 基本操作  ]**

```csharp
# Task.CompletedTask
async def completed_task():
      return None


```

```csharp
# Task<int>
async def M1(delay: int) -> int:
	await asyncio.sleep(delay)
	return delay

# 1
o = asyncio.run(M1(1))
print(o)
        
        
```



#### **[ 异步迭代 ]**

```csharp
// [ 阻塞 ] 等待所有任务完成 ( 按提交顺序返回 )
// async def M2():
//     from tqdm.asyncio import tqdm
// 	   coroutines = [M1(i) for i in [1, 2, 3, 4, 5]]
//         
//     # 使用 tqdm 包装协程列表
// 	   res = await tqdm.gather(*coroutines, desc="任务进行中...")
// 	   return res

# [ 阻塞 ] 等待所有任务完成 ( 按提交顺序返回 )
async def M2():
	async with asyncio.TaskGroup() as tg:
		tasks = [tg.create_task(M1(i)) for i in [1, 2, 3, 4, 5]]

	res = [ x.result() for x in tasks ]
	return res
            
async def main():
	for x in await M2():
		print(x)

asyncio.run(main())
            
            
```

```csharp
# [ 非阻塞 ] 1,... 2,... 3,...
# M2: 返回异步迭代器 ( AsyncIterator[ ... ] )
async def M2():
	from tqdm.asyncio import tqdm
	coroutines = [M1(i) for i in [1, 2, 3, 4, 5]]

	# [ 进度条 ] 共 5 个任务度
	with tqdm(total = len(coroutines), desc="整体任务进度", leave=True) as pbar:
		for task in coroutines:
			result = await task
			# [ 更新进度条 ] 完成任务度 +1
			pbar.update(1)
			yield result

async def main():
	# 在 Python 中 async for : 用于异步迭代
	async for x in M2():
		print(x)

asyncio.run(main())
            
            
```



<!-- tabs:end -->





