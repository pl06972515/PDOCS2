<br/>

<!-- tabs:start -->

#### **Class**

>[!WARNING|style: flat|label: 简要说明 ]
>
>- 在`Python`中，约定私有成员由`private: 双下划线 __ 开头`
>
>   <span style='color:red'>[ 名称改写机制：将私有成员的名称隐式改为`_ClassName__MemberName`从而防止直接访问 ]</span>
>
>- 在`Python`中，约定受保护成员由`protected: 单下划线 _ 开头`
>
>```csharp
>class TClass:
>    def __init__(self):
>        self.__x = 10
>        self._y = 100
>
>    def __M1(self):
>        print(self.__x)
>
>
>```
>
>```csharp
>o = TClass()
>
>v1 = o._TClass__x // obj.__x [ 因名称改写机制 ] 访问导致 AttributeError   
>o._TClass__M1()
>
>// [ 受保护成员 ] 可以直接访问, 但约定不应该在类外部直接访问
>// v2 = o._y 
>
>
>```
>
><br/>

```csharp
class TClass:
    
    // [ 构造函数 ] 在 Python 中, 构造函数唯一
    def __init__(self, *, x, y, z):
        self.__x = x  // [ 私有字段 ] 通过 __ 来修饰
        self.__y = y
        self.z = z    // [ 公共字段 ]

    // [ 写属性 ]
    def set_X(self, x):
        self.__x = x
    // [ 读属性 ] 通过装饰器 @property 标注 ( 使方法可以通过 - 属性访问的方式调用方法 )
    @property
    def X(self):
        return self.__x
            
    /// <summary>
    /// - [ 方法定义 ] 首个参数固定 self ( this )
    /// - [ 方法调用 ] 传递参数忽略 self
    /// 
    /// </summary>
    def M1(self):
        print(f"x: {self.__x}, y: {self.__y}, z: {self.z}")
        return self.__x + self.__y
    
    // [ 私有函数 ] 通过 __ 来修饰
    def __M2(self):
        print(f"姓名: {self.Name}, 年龄: {self.Age}, 性别: {self.Sex}")
            
    // [ 静态函数 ] 通过装饰器 @staticmethod 标注
    @staticmethod
    def M3(x, y):
        return x + y  
            
    // [ 重写 ] .ToString()
    def __str__(self):
        return f"姓名: {self.Name}, 年龄: {self.Age}, 性别: {self.Sex}"
            
    /// <summary>
    /// [ 重写 ] 操作符
    ///   1.__add__(self, other)：加法 +
    ///   2.__sub__(self, other)：减法 -
    ///   3.__mul__(self, other)：乘法 *
    ///   4.__truediv__(self, other)：除法 /
    ///   5.__floordiv__(self, other)：整除 //
    ///   6. __mod__(self, other)：取模 %
    /// 
    ///   1.__eq__(self, other)：等于 ==
    ///   2.__ne__(self, other)：不等于 !=
    /// 
    ///   1.__gt__(self, other)：大于 >
    ///   2.__ge__(self, other)：大于等于 >=
    ///   3.__lt__(self, other)：小于 <
    ///   4.__le__(self, other)：小于等于 <=
    /// 
    /// </summary>
    def __lt__(self, other):
        return self.Age < other.Age

            
```

>```csharp
>// [ 创建对象 ]
>o = TClass(x=1, y=2, z=3)
>v1 = o.M1()
>v2 = o.X
>
>TClass.M3(10, 20)
>    
>    
>```
>
>
>
>



#### **[ ☢ 继承多态 ]**

```csharp
from abc import ABC, abstractmethod
from typing_extensions import override

// [ 抽象类 ] 约定继承自 ABC
class Base(ABC):

    def __init__(self, x, y):
        self.__x = x
        self._y = y

    // [ 抽象方法 ] 通过装饰器 @abstractmethod 标注
    @abstractmethod
    def M1(self):
        pass

        
```

```csharp
class TClass(Base):

    // [ 调用基类构造 ] super() 等效 base
    def __init__(self, x):
        super().__init__(x, 20) 

    // [ 方法实现 ] 通过装饰器 @override 标注
    @override
    def M1(self):
        print(self._y + self._Base__x)

o = TClass(10)
o.M1()
            
            
```



#### **[ ☢ 多重继承 ]**

!> <span style='color:red'>在`Python`中允许多重继承，在多重继承情况下 [ 构造函数参数请使用`*args`或`**kwargs`可避免混乱以及参数匹配异常 ]</span>

```csharp
from abc import ABC, abstractmethod
from typing_extensions import override

class Base(ABC):
    def __init__(self, **kwargs):
        self.X = 10
        print("Base")
            
    def M1(self):
        print(self.X)

            
```

```csharp
class S1Class(Base, ABC):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.X = 20
        print("S1Class")

class S2Class(Base, ABC):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.X = 30
        print("S2Class")
            
class TClass(S1Class, S2Class):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        print("TClass")
             
             
```

>```csharp
>o = TClass(x = 10, y = 20)
>// 20 【 因 TClass 构造函传递顺序是：TClass -> S1Class( 由最近基类赋值 ) -> S2Class -> ABC -> Base -> object 】
>o.M1()
>    
>    
>```
>
>
>
>





<!-- tabs:end -->


